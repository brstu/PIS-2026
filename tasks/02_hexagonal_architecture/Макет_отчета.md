<p align="center">Министерство образования Республики Беларусь</p>
<p align="center">Учреждение образования</p>
<p align="center">"Брестский Государственный технический университет"</p>
<p align="center">Кафедра ИИТ</p>
<br><br><br><br><br><br>
<p align="center"><strong>Лабораторная работа №2</strong></p>
<p align="center"><strong>По дисциплине:</strong> "Проектирование интернет-систем"</p>
<p align="center"><strong>Тема:</strong> "Гексагональная архитектура: проектирование портов и адаптеров"</p>
<br><br><br><br><br><br>
<p align="right"><strong>Выполнил:</strong></p>
<p align="right">Студент 3 курса</p>
<p align="right">Группа _[ваша группа]_</p>
<p align="right">_[ваше ФИО]_</p>
<p align="right"><strong>Проверил:</strong></p>
<p align="right">Несюк А.Н.</p>
<br><br><br><br><br>
<p align="center"><strong>Брест 2026</strong></p>

---

## Цель работы

Спроектировать архитектуру основного сервиса системы с использованием гексагональной (hexagonal) архитектуры: создать структуру проекта, определить порты (интерфейсы) и продемонстрировать изоляцию слоёв через минимальные примеры.

---

## Вариант №_[номер]_ — _[Название системы из ВАРИАНТЫ_ЛАБОРАТОРНЫХ.md]_

**Питч:** _[Скопировать из ВАРИАНТЫ_ЛАБОРАТОРНЫХ.md]_  
**Ядро домена:** _[Перечислить основные сущности]_

**Выбранный сервис:** _[Например: Request Service, Task Service, Booking Service]_

---

## Ход выполнения работы

### Часть 1. Архитектурная диаграмма

**Описание сервиса:** _[Кратко опишите, что делает ваш сервис: основные операции, ключевые сущности]_

**Пример для ПСО «Юго-Запад» (Request Service)**:
> Request Service управляет жизненным циклом поисково-спасательных заявок: создание заявки, назначение группы, распределение по зонам, уведомления волонтёров. Основные сущности: Request (Заявка), Group (Группа), Zone (Зона поиска), Volunteer (Участник).

**Диаграмма слоёв:**

_[Вставьте диаграмму, показывающую domain → application → infrastructure]_

**Пример**:
```
┌─────────────────────────────────────────────┐
│   Infrastructure Layer                      │
│  ┌──────────────┐    ┌──────────────────┐   │
│  │ REST         │    │ InMemory         │   │
│  │ Controller   │    │ RequestRepository│   │
│  └──────┬───────┘    └─────────┬────────┘   │
│         │                      │             │
└─────────┼──────────────────────┼─────────────┘
          │                      │
          ▼                      ▼
┌─────────────────────────────────────────────┐
│   Application Layer                         │
│  ┌──────────────┐    ┌──────────────────┐   │
│  │ In Ports     │    │ Out Ports        │   │
│  │ (Use Cases)  │    │ (Dependencies)   │   │
│  └──────┬───────┘    └─────────┬────────┘   │
│         │                      │             │
│  ┌──────▼──────────────────────▼─────────┐  │
│  │    RequestService (Orchestrator)      │  │
│  └───────────────────────────────────────┘  │
└─────────────────┬───────────────────────────┘
                  │
                  ▼
┌──────────────────────────────────────────────┐
│       Domain Layer                           │
│  ┌─────────┐  ┌─────────┐  ┌──────────┐     │
│  │ Request │  │ Group   │  │ Zone     │     │
│  │(Aggregate)│ │(Entity) │  │(Value Obj)│   │
│  └─────────┘  └─────────┘  └──────────┘     │
└──────────────────────────────────────────────┘
```

---

### Часть 2. Структура проекта (скелет)

**Технология:** _[Python, Java, C#, Node.js]_

**Структура папок:**

```
_[Вставьте дерево папок вашего проекта]_

Пример для Request Service (Python):
request-service/
├── README.md
├── src/
│   ├── domain/
│   │   ├── models/
│   │   │   ├── request.py          # class Request
│   │   │   ├── group.py            # class Group  
│   │   │   └── zone.py             # class Zone (Value Object)
│   │   └── exceptions/
│   │       └── domain_exception.py
│   ├── application/
│   │   ├── port/
│   │   │   ├── in/
│   │   │   │   ├── create_request_use_case.py
│   │   │   │   └── assign_group_use_case.py
│   │   │   └── out/
│   │   │       ├── request_repository.py
│   │   │       └── notification_service.py
│   │   └── service/
│   │       └── request_service.py   # Скелет с TODO
│   └── infrastructure/
│       ├── adapter/
│       │   ├── in/
│       │   │   └── request_controller.py
│       │   └── out/
│       │       └── in_memory_request_repository.py
│       └── config/
│           └── dependency_injection.py
└── Architecture.md                   # Диаграммы + пояснения
```

**Скриншот структуры в IDE**:

_[Вставьте скриншот дерева проекта из VS Code / IntelliJ / Visual Studio]_

---

### Часть 3. Domain Layer (Доменный слой)

#### Доменные сущности

**Entity 1**: _[Название, например: Order]_

```java
// Код класса Order.java
_[Вставьте код вашего класса]_
```

**Value Object 1**: _[Название, например: Money]_

```java
// Код класса Money.java
_[Вставьте код]_
```

**Доменные исключения**:
- _[Например: InsufficientStockException]_
- _[Например: InvalidOrderStateException]_

#### Бизнес-правила

Перечислите основные бизнес-правила, реализованные в domain слое:

1. _[Например: "Нельзя изменить подтверждённый заказ"]_
2. _[Например: "Общая сумма заказа не может быть отрицательной"]_
3. _[...]_

---

### Часть 4. Application Layer (Прикладной слой)

#### Входящие порты (Inbound Ports)

Интерфейсы, которые предоставляет система внешнему миру:

**ICreateOrderUseCase**:
```java
_[Код интерфейса]_
```

**IGetOrderUseCase**:
```java
_[Код интерфейса]_
```

#### Исходящие порты (Outbound Ports)

Интерфейсы, через которые система взаимодействует с внешним миром:

**IOrderRepository**:
```java
_[Код интерфейса]_
```

**IPaymentGateway**:
```java
_[Код интерфейса]_
```

_[Перечислите другие порты, если есть]_

#### Application Service

**OrderService** (реализует входящие порты):

```java
_[Код класса OrderService]_
```

**Основная логика**:
_[Кратко опишите, как работает метод createOrder: шаги, вызовы портов]_

---

### Часть 5. Infrastructure Layer (Инфраструктурный слой)

#### Входящий адаптер: REST API

**OrderController**:

```java
_[Код REST-контроллера]_
```

**Эндпоинты**:
- `POST /api/orders` — создание заказа
- `GET /api/orders/{id}` — получение заказа

**Пример запроса/ответа**:

```json
POST /api/orders
{
  "customerId": "customer-123",
  "items": [
    {"productId": "prod-1", "quantity": 2, "price": {"amount": 100, "currency": "USD"}}
  ]
}

Ответ:
{
  "orderId": "order-456"
}
```

#### Исходящий адаптер: Repository

**InMemoryOrderRepository** (или PostgreSQLRepository):

```java
_[Код реализации репозитория]_
```

**Принцип работы**:
_[Опишите, как хранятся данные: в памяти, в БД, файл]_

#### Исходящий адаптер: Payment Gateway

**MockPaymentGateway** (или реальная интеграция):

```java
_[Код адаптера для платежей]_
```

**Логика**:
_[Опишите: имитация успешной оплаты, логирование, генерация paymentId]_

---

### Часть 6. Dependency Injection (Конфигурация зависимостей)

**BeanConfiguration** (или DI-контейнер):

```java
_[Код конфигурации Spring/CDI/.NET]_
```

**Как работает DI**:
_[Опишите: какие бины создаются, как они инжектятся в OrderService]_

---

### Часть 7. Тестирование

#### Юнит-тесты для OrderService

```java
_[Код теста, например: testCreateOrderSuccess()]_
```

**Что тестируется**:
- ✅ Успешное создание заказа
- ✅ Вызов PaymentGateway с корректной суммой
- ✅ Сохранение заказа в репозиторий

**Mock-объекты**:
_[Опишите, как вы мокируете OrderRepository и PaymentGateway]_

**Результаты тестов**:

_[Вставьте скриншот прохождения тестов в IDE или вывод команды `mvn test`]_

---

## 3. Архитектурная диаграмма

### Диаграмма слоёв

```
_[Создайте диаграмму, показывающую:
- Domain (центр)
- Application (порты)
- Infrastructure (адаптеры)
- Направление зависимостей (стрелки)]_
```

**Пример** (можно нарисовать в draw.io, PlantUML или от руки):

```
┌─────────────────────────────────┐
│   Infrastructure Layer          │
│  ┌─────────┐    ┌──────────┐    │
│  │  REST   │    │ Postgres │    │
│  │Controller│   │Repository│    │
│  └────┬────┘    └─────┬────┘    │
│       │               │          │
└───────┼───────────────┼──────────┘
        │               │
        ▼               ▼
┌──────────────────────────────────┐
│   Application Layer              │
│  ┌─────────┐    ┌──────────┐    │
│  │In Ports │    │Out Ports │    │
│  └────┬────┘    └─────┬────┘    │
│       │               │          │
│  ┌────▼────────────────▼─────┐  │
│  │    OrderService           │  │
│  └───────────────────────────┘  │
└──────────────┬───────────────────┘
               │
               ▼
┌───────────────────────────────────┐
│       Domain Layer                │
│  ┌──────┐  ┌──────┐  ┌──────┐    │
│  │Order │  │Money │  │Status│    │
│  └──────┘  └──────┘  └──────┘    │
└───────────────────────────────────┘
```

### Описание портов и адаптеров

| Тип | Название | Назначение |
|-----|----------|------------|
| **Входящий порт** | ICreateOrderUseCase | _[Интерфейс для создания заказа]_ |
| **Входящий порт** | IGetOrderUseCase | _[Интерфейс для получения заказа]_ |
| **Исходящий порт** | IOrderRepository | _[Интерфейс для хранения заказов]_ |
| **Исходящий порт** | IPaymentGateway | _[Интерфейс для оплаты]_ |
| **Входящий адаптер** | OrderController (REST) | _[REST API для клиентов]_ |
| **Исходящий адаптер** | InMemoryOrderRepository | _[Реализация хранилища в памяти]_ |
| **Исходящий адаптер** | MockPaymentGateway | _[Имитация платёжного шлюза]_ |

---

## 4. Критерии выполнения

| Критерий | Выполнено | Комментарий |
|----------|-----------|-------------|
| Структура проекта (domain/application/infrastructure) | ❌ / ✅ | _[Ваш комментарий]_ |
| Domain Layer (чистая бизнес-логика) | ❌ / ✅ | _[...]_ |
| Порты (входящие и исходящие интерфейсы) | ❌ / ✅ | _[...]_ |
| Адаптеры (минимум 1 входящий + 2 исходящих) | ❌ / ✅ | _[...]_ |
| DI-конфигурация (зависимости инжектятся) | ❌ / ✅ | _[...]_ |
| Юнит-тесты для OrderService с моками | ❌ / ✅ | _[...]_ |
| Документация (диаграмма, описание) | ❌ / ✅ | _[...]_ |

**Итого**: _[Количество выполненных критериев]_ / 7

---

## 5. Бонусные задания (если выполнены)

| Бонус | Выполнено | Комментарий |
|-------|-----------|-------------|
| EventBus для уведомлений | ❌ / ✅ | _[...]_ |
| Замена на реальную БД (PostgreSQL/MongoDB) | ❌ / ✅ | _[...]_ |
| GraphQL адаптер | ❌ / ✅ | _[...]_ |
| Интеграционные тесты (TestContainers) | ❌ / ✅ | _[...]_ |
| CQRS разделение | ❌ / ✅ | _[...]_ |

---

## 6. Выводы

### Что получилось хорошо

_[Опишите, какие части архитектуры удалось реализовать успешно]_

**Пример**:
> Удалось чётко отделить бизнес-логику (Order, Money) от инфраструктуры. Domain слой не имеет зависимостей от Spring или БД аннотаций. OrderService легко тестируется с моками.

### С какими трудностями столкнулись

_[Опишите проблемы: настройка DI, тестирование, понимание портов/адаптеров]_

**Пример**:
> Было сложно понять, зачем создавать интерфейс для порта, если у него только одна реализация. После изучения статьи про Dependency Inversion стало ясно: это для тестируемости и возможности замены адаптера.

### Что узнали нового

_[Перечислите концепции: Hexagonal Architecture, Ports & Adapters, DIP, DI]_

**Пример**:
> Изучил принцип Dependency Inversion: domain не зависит от деталей реализации. Понял, как гексагональная архитектура упрощает замену БД или UI без изменения бизнес-логики.

### Как можно улучшить

_[Идеи для дальнейшего развития проекта]_

**Пример**:
> Добавить реальную БД (PostgreSQL), реализовать EventBus для асинхронных уведомлений, написать интеграционные тесты с TestContainers.

---

## 7. Приложения (опционально)

### Ссылка на репозиторий

_[https://github.com/username/project-name]_

### Скриншоты

**Работающий API** (Postman/curl):

_[Вставьте скриншот запроса и ответа]_

**Структура проекта в IDE**:

_[Скриншот дерева файлов]_

**Прохождение тестов**:

_[Скриншот `mvn test` или вывода IDE]_

---

**Дата сдачи**: _[ДД.ММ.ГГГГ]_  
**Подпись студента**: _[Фамилия И.О.]_
